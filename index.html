<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç­”é¢˜ç³»ç»Ÿ</title>
    <style>
        *{box-sizing:border-box;margin:0;padding:0;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif}
        body{background:linear-gradient(135deg,#6a11cb 0%,#2575fc 100%);color:#333;line-height:1.6;min-height:100vh;padding:20px}
        .container{max-width:900px;margin:0 auto}
        .card{background:white;border-radius:15px;box-shadow:0 10px 30px rgba(0,0,0,0.2);padding:30px;margin-bottom:20px;transition:transform .3s,box-shadow .3s}
        .card:hover{transform:translateY(-5px);box-shadow:0 15px 35px rgba(0,0,0,0.3)}
        h1{text-align:center;color:#2c3e50;margin-bottom:20px;font-size:2.5rem;background:linear-gradient(90deg,#2575fc,#6a11cb);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
        h2{color:#3498db;margin-bottom:15px;border-bottom:2px solid #f0f0f0;padding-bottom:10px}
        .form-group{margin-bottom:20px}
        label{display:block;margin-bottom:8px;font-weight:bold;color:#555}
        input[type="text"]{width:100%;padding:15px;border:2px solid #ddd;border-radius:8px;font-size:16px;transition:border-color .3s}
        input[type="text"]:focus{border-color:#3498db;outline:none;box-shadow:0 0 0 3px rgba(52,152,219,0.2)}
        button{background:linear-gradient(90deg,#3498db,#2980b9);color:white;border:none;padding:15px 25px;border-radius:8px;cursor:pointer;font-size:16px;font-weight:bold;transition:all .3s;box-shadow:0 4px 6px rgba(0,0,0,0.1)}
        button:hover{transform:translateY(-2px);box-shadow:0 6px 8px rgba(0,0,0,0.15)}
        button:active{transform:translateY(0)}
        .btn-secondary{background:linear-gradient(90deg,#95a5a6,#7f8c8d)}
        .btn-success{background:linear-gradient(90deg,#2ecc71,#27ae60)}
        .btn-danger{background:linear-gradient(90deg,#e74c3c,#c0392b)}
        .question{margin-bottom:25px;padding-bottom:15px;border-bottom:1px solid #eee}
        .options{margin-top:10px}
        .option{display:block;margin-bottom:10px;padding:15px;border:2px solid #ddd;border-radius:8px;cursor:pointer;transition:all .2s}
        .option:hover{background-color:#f8f9fa;border-color:#3498db}
        .option.selected{background-color:#3498db;color:white;border-color:#2980b9}
        .timer{text-align:center;font-size:20px;margin-bottom:20px;color:#e74c3c;font-weight:bold}
        .countdown-timer{text-align:center;font-size:18px;margin-bottom:15px;color:#2ecc71;font-weight:bold;background:#d4edda;padding:10px;border-radius:8px;border:2px solid #c3e6cb;transition:all .3s}
        .countdown-warning{background:#fff3cd;color:#856404;border-color:#ffeaa7;animation:warning-pulse 1s infinite}
        .countdown-danger{background:#f8d7da;color:#721c24;border-color:#f5c6cb;animation:danger-pulse .5s infinite}
        .progress{height:12px;background-color:#ecf0f1;border-radius:6px;margin-bottom:20px;overflow:hidden}
        .progress-bar{height:100%;background:linear-gradient(90deg,#2ecc71,#27ae60);width:0%;transition:width .5s;border-radius:6px}
        .ranking-table{width:100%;border-collapse:collapse}
        .ranking-table th,.ranking-table td{padding:15px;text-align:left;border-bottom:1px solid #ddd}
        .ranking-table th{background:linear-gradient(90deg,#3498db,#2980b9);color:white;font-weight:bold}
        .ranking-table tr:hover{background-color:#f5f7fa}
        .ranking-table .top-1{background-color:#fff9e6}
        .ranking-table .top-2{background-color:#f0f8ff}
        .ranking-table .top-3{background-color:#f9f2ff}
        .hidden{display:none}
        .flex{display:flex;justify-content:space-between;align-items:center;gap:10px}
        .result{text-align:center;padding:20px}
        .score{font-size:36px;font-weight:bold;background:linear-gradient(90deg,#2ecc71,#27ae60);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin:20px 0}
        .time-used{font-size:20px;color:#7f8c8d;margin-bottom:20px}
        .user-info{background:linear-gradient(90deg,#f8f9fa,#e9ecef);padding:15px;border-radius:10px;margin-bottom:20px;display:flex;justify-content:space-between;font-weight:bold}
        .badge{display:inline-block;padding:5px 10px;border-radius:20px;font-size:14px;font-weight:bold;margin-left:10px}
        .badge-primary{background-color:#3498db;color:white}
        .badge-success{background-color:#2ecc71;color:white}
        .badge-secondary{background-color:#6c757d;color:white}
        .badge-warning{background-color:#f39c12;color:white}
        .instructions{background-color:#f8f9fa;padding:15px;border-radius:10px;margin-bottom:20px;border-left:5px solid #3498db}
        .github-info{background:linear-gradient(90deg,#d4edda,#c3e6cb);padding:12px 15px;border-radius:8px;margin:15px 0;border-left:4px solid #28a745}
        .sync-status{padding:12px 15px;border-radius:8px;margin:10px 0;font-size:14px;display:flex;align-items:center}
        .sync-success{background:#d4edda;color:#155724;border:1px solid #c3e6cb}
        .sync-error{background:#f8d7da;color:#721c24;border:1px solid #f5c6cb}
        .sync-loading{background:#d1ecf1;color:#0c5460;border:1px solid #bee5eb}
        .loading{display:inline-block;width:20px;height:20px;border:3px solid #f3f3f3;border-top:3px solid #3498db;border-radius:50%;animation:spin 1s linear infinite;margin-right:10px}
        .online-indicator{display:inline-block;width:10px;height:10px;border-radius:50%;background-color:#2ecc71;margin-right:5px;animation:pulse 2s infinite}
        @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
        @keyframes pulse{0%{opacity:1}50%{opacity:0.5}100%{opacity:1}}
        @keyframes warning-pulse{0%{background-color:#fff3cd}50%{background-color:#ffeaa7}100%{background-color:#fff3cd}}
        @keyframes danger-pulse{0%{background-color:#f8d7da}50%{background-color:#f5c6cb}100%{background-color:#f8d7da}}
        @media (max-width:768px){.container{padding:10px}.card{padding:20px}h1{font-size:2rem}.flex{flex-direction:column}button{width:100%;margin-bottom:10px}}
    </style>
</head>
<body>
    <div class="container">
        <div id="login-screen" class="card">
            <h1>ç­”é¢˜ç³»ç»Ÿ</h1>
            <div class="github-info">
                <p style="margin:0;font-weight:bold;color:#155724;">
                    <span class="online-indicator"></span>
                    GitHubå®æ—¶åŒæ­¥ - æˆç»©è‡ªåŠ¨ä¸Šä¼ åˆ°Issues
                </p>
            </div>
            <div class="instructions">
                <p><strong>ä½¿ç”¨è¯´æ˜ï¼š</strong></p>
                <p>1. è¾“å…¥æ˜µç§°å¼€å§‹ç­”é¢˜</p>
                <p>2. å¼€å§‹ç­”é¢˜åæœ‰10åˆ†é’Ÿæ—¶é—´å®Œæˆæäº¤</p>
                <p>3. å¿…é¡»åœ¨10åˆ†é’Ÿå†…å®Œæˆæ‰€æœ‰é¢˜ç›®å¹¶æäº¤</p>
                <p>4. è¶…æ—¶æäº¤å°†æ— æ³•ä¿å­˜æˆç»©</p>
            </div>
            <div class="form-group">
                <label for="nickname">è¯·è¾“å…¥æ‚¨çš„æ˜µç§°ï¼š</label>
                <input type="text" id="nickname" placeholder="è¯·è¾“å…¥æ˜µç§°ï¼ˆ2-10ä¸ªå­—ç¬¦ï¼‰" maxlength="10">
            </div>
            <div class="flex">
                <button id="start-btn">å¼€å§‹ç­”é¢˜</button>
                <button id="view-ranking-btn" class="btn-secondary">å®æ—¶æ’è¡Œæ¦œ</button>
            </div>
            <div id="sync-status" class="sync-status" style="display:none"></div>
        </div>

        <div id="quiz-screen" class="card hidden">
            <div class="user-info">
                <span>ç”¨æˆ·ï¼š<span id="current-user"></span></span>
                <span>è¿›åº¦ï¼š<span id="progress-text">0/0</span></span>
            </div>
            <div class="countdown-timer" id="countdown-timer">å‰©ä½™æ—¶é—´ï¼š10:00</div>
            <div class="progress">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="timer">ç”¨æ—¶ï¼š<span id="timer">00:00</span></div>
            <div id="question-container"></div>
            <div class="flex">
                <button id="prev-btn" class="btn-secondary">ä¸Šä¸€é¢˜</button>
                <button id="next-btn">ä¸‹ä¸€é¢˜</button>
            </div>
        </div>

        <div id="result-screen" class="card hidden">
            <div class="result">
                <h2 id="result-title">ç­”é¢˜å®Œæˆï¼</h2>
                <p>æ‚¨çš„å¾—åˆ†ï¼š</p>
                <div class="score" id="final-score">0</div>
                <p class="time-used">ç”¨æ—¶ï¼š<span id="final-time">00:00</span></p>
                <div class="sync-status" id="upload-status" style="display:none"></div>
                <div class="flex">
                    <button id="view-ranking-btn-2">æŸ¥çœ‹å®æ—¶æ’è¡Œæ¦œ</button>
                    <button id="restart-btn" class="btn-secondary">å†ç­”ä¸€æ¬¡</button>
                    <button id="create-issue-btn" class="btn-success">åˆ›å»ºGitHub Issue</button>
                </div>
            </div>
        </div>

        <div id="ranking-screen" class="card hidden">
            <div class="flex">
                <h2>å®æ—¶æ’è¡Œæ¦œ</h2>
                <div style="display:flex;align-items:center">
                    <span class="online-indicator"></span>
                    <span style="font-size:14px;color:#28a745" id="ranking-source">æ•°æ®æ¥è‡ªGitHub Issues</span>
                </div>
            </div>
            <table class="ranking-table">
                <thead>
                    <tr><th>æ’å</th><th>æ˜µç§°</th><th>åˆ†æ•°</th><th>ç”¨æ—¶</th><th>æäº¤æ—¶é—´</th></tr>
                </thead>
                <tbody id="ranking-body"></tbody>
            </table>
            <div style="margin-top:20px;text-align:center">
                <button id="back-to-start-btn">è¿”å›é¦–é¡µ</button>
                <button id="refresh-ranking-btn" class="btn-secondary" style="margin-left:10px">åˆ·æ–°æ’è¡Œæ¦œ</button>
                <button id="auto-refresh-toggle" class="btn-success" style="margin-left:10px">è‡ªåŠ¨åˆ·æ–°: å¼€</button>
            </div>
        </div>
    </div>

    <script>
        // ==== é¢˜ç›®æ•°æ® ====
        const questions = [
            {id:1,question:"éå…¨æ—¥åˆ¶ã€ä¸“å‡æœ¬ã€æˆäººé«˜è€ƒç­‰å½¢å¼çš„æ‹›ç”Ÿç”±ï¼ˆï¼‰è´Ÿè´£ã€‚",options:["å‰æ—å¤§å­¦æœ¬ç§‘ç”Ÿæ‹›ç”ŸåŠå…¬å®¤","å‰æ—å¤§å­¦ç»§ç»­æ•™è‚²å­¦é™¢","å‰æ—å¤§å­¦å›½é™…æ•™è‚²å­¦é™¢","å‰æ—å¤§å­¦è±å§†é¡¿å­¦é™¢"],answer:1,type:"choice"},
            {id:2,question:"ä¸‹åˆ—æŠ¥è€ƒæ–¹å¼ä¸­é‡‡å–åœ¨ä¸“ä¸šç»„å†…è°ƒå‰‚çš„æ˜¯ï¼ˆï¼‰ã€‚",options:["é™¢æ ¡+ä¸“ä¸š","é™¢æ ¡+ä¸“ä¸šç»„","ä¸“ä¸š+é™¢æ ¡"],answer:1,type:"choice"},
            {id:3,question:"åœ¨2026å¹´é«˜è€ƒä¸­ï¼ˆï¼‰å’Œï¼ˆï¼‰å®è¡Œä¼ ç»Ÿæ–‡ç†åˆ†ç§‘çš„é€‰ç§‘æ¨¡å¼ã€‚",options:["æ–°ç–†ã€é’æµ·","æ–°ç–†ã€äº‘å—","è¥¿è—ã€æ–°ç–†","è¥¿è—ã€å®å¤"],answer:2,type:"choice"},
            {id:4,question:"â€œæ»‘æ¡£â€çš„è€ƒç”Ÿåªèƒ½ç­‰å¾…ï¼ˆï¼‰å¾é›†å¿—æ„¿æˆ–ä¸‹ä¸€æ‰¹æ¬¡çš„å½•å–ã€‚",options:["æœ¬æ‰¹æ¬¡","ä¸Šä¸€æ‰¹æ¬¡","ä¸‹ä¸€æ‰¹æ¬¡"],answer:0,type:"choice"},
            {id:5,question:"â€œæŠ•æ¡£â€å³ï¼ˆï¼‰æŠŠè€ƒç”Ÿæ¡£æ¡ˆæŠ•åˆ°äº†å¯¹åº”é™¢æ ¡ã€‚",options:["é™¢æ ¡æ‹›ç”ŸåŠ","è€ƒç”Ÿæœ¬äºº","è€ƒç”Ÿæ‰€åœ¨é«˜ä¸­","çœè€ƒè¯•é™¢"],answer:3,type:"choice"},
            {id:6,question:"å¹³è¡Œå¿—æ„¿å½•å–è§„åˆ™çš„æ ¸å¿ƒæ˜¯ï¼ˆï¼‰ä¼˜å…ˆã€éµå¾ªï¼ˆï¼‰ã€‚",type:"fill",correctAnswers:["åˆ†æ•°","å¿—æ„¿"],requiredMatches:2},
            {id:7,question:"å‰æ—å¤§å­¦æ‹›ç”Ÿåä¼šæ˜¯ï¼ˆï¼‰ç›´å±å­¦ç”Ÿç¤¾å›¢ã€‚",type:"fill",correctAnswers:["å‰æ—å¤§å­¦æœ¬ç§‘ç”Ÿæ‹›ç”ŸåŠå…¬å®¤","å‰å¤§æœ¬æ‹›åŠ"],requiredMatches:2},
            {id:8,question:"å‰æ—å¤§å­¦\"2+7\"æ‹”å°–äººæ‰åŸ¹å…»ä½“ç³»ä¸­çš„\"2\"æŒ‡çš„æ˜¯ï¼ˆï¼‰ç­å’Œï¼ˆï¼‰ç­ã€‚",type:"fill",correctAnswers:["å”æ•–åº†","åŒ¡äºšæ˜"],requiredMatches:2},
            {id:9,question:"ä¸¾å‡ºå‰æ—å¤§å­¦ä¸€ä¸ªä¸“ä¸šç‰¹è‰²ç­ï¼›ï¼ˆï¼‰ã€‚",type:"fill",correctAnswers:["PPEï¼ˆå“²å­¦ã€æ”¿æ²»å­¦ã€ç»æµå­¦ï¼‰","æ¶‰å¤–æ³•æ²»äººæ‰è¯•éªŒç­","çœ¼ç§‘å­¦","ç”Ÿç‰©è‚²ç§ç‰¹è‰²ç­","é›†æˆç”µè·¯ç§‘æŠ€è‹±æ‰ç‰¹è‰²ç­","PPE"],requiredMatches:1},
            {id:10,question:"å‰æ—å¤§å­¦æœ‰ï¼ˆï¼‰ä¸ª\"åŒä¸€æµ\"å»ºè®¾å­¦ç§‘ï¼ˆç¾¤ï¼‰ã€‚",type:"fill",correctAnswers:["12"],requiredMatches:1}
        ];

        // ==== æ—¶é—´ç®¡ç†å™¨ ====
        const TimeManager = {
            quizStartTime: null,
            timeLimit: 600000, // 10åˆ†é’Ÿ
            countdownInterval: null,
            timeRemaining: 0,
            
            startQuiz() {
                this.quizStartTime = new Date();
                this.timeRemaining = this.timeLimit;
                this.startCountdown();
            },
            
            isTimeUp() {
                if (!this.quizStartTime) return false;
                return new Date() - this.quizStartTime > this.timeLimit;
            },
            
            getRemainingTime() {
                if (!this.quizStartTime) return this.timeLimit;
                return Math.max(0, this.timeLimit - (new Date() - this.quizStartTime));
            },
            
            startCountdown() {
                if (this.countdownInterval) clearInterval(this.countdownInterval);
                
                this.countdownInterval = setInterval(() => {
                    this.timeRemaining = this.getRemainingTime();
                    
                    if (this.timeRemaining <= 0) {
                        this.timeRemaining = 0;
                        this.stopCountdown();
                        this.handleTimeUp();
                        return;
                    }
                    
                    this.updateCountdownDisplay();
                    this.updateCountdownStyle();
                }, 1000);
                
                this.updateCountdownDisplay();
                this.updateCountdownStyle();
            },
            
            stopCountdown() {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
            },
            
            updateCountdownDisplay() {
                const minutes = Math.floor(this.timeRemaining / 60000);
                const seconds = Math.floor((this.timeRemaining % 60000) / 1000);
                document.getElementById('countdown-timer').textContent = 
                    `å‰©ä½™æ—¶é—´ï¼š${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            },
            
            updateCountdownStyle() {
                const element = document.getElementById('countdown-timer');
                element.classList.remove('countdown-warning', 'countdown-danger');
                
                if (this.timeRemaining <= 60000) {
                    element.classList.add('countdown-danger');
                } else if (this.timeRemaining <= 180000) {
                    element.classList.add('countdown-warning');
                }
            },
            
            handleTimeUp() {
                const element = document.getElementById('countdown-timer');
                element.textContent = 'æ—¶é—´åˆ°ï¼ç­”é¢˜å·²ç»“æŸ';
                element.classList.add('countdown-danger');
                
                const nextBtn = document.getElementById('next-btn');
                if (nextBtn.textContent === 'æäº¤ç­”æ¡ˆ') {
                    nextBtn.click();
                } else {
                    submitQuiz();
                }
                
                setTimeout(() => {
                    alert('ç­”é¢˜æ—¶é—´å·²ç»“æŸï¼ç³»ç»Ÿå·²è‡ªåŠ¨æäº¤æ‚¨çš„ç­”æ¡ˆã€‚');
                }, 500);
            },
            
            getTimeUsed() {
                if (!this.quizStartTime) return 0;
                return Math.min(Math.floor((new Date() - this.quizStartTime) / 1000), this.timeLimit / 1000);
            },
            
            isValidSubmission() {
                return !this.isTimeUp();
            },
            
            reset() {
                this.stopCountdown();
                this.quizStartTime = null;
                this.timeRemaining = this.timeLimit;
            }
        };

        // ==== GitHubæœåŠ¡ ====
        const GitHubService = {
            autoRefreshInterval: null,
            autoRefreshEnabled: true,
            currentRanking: [],
            demoGitHubData: [], // æ¼”ç¤ºæ•°æ®
            
            init() {
                this.showSyncStatus('âœ… æ’è¡Œæ¦œç³»ç»Ÿå·²å¯ç”¨', 'sync-success');
                this.loadDemoData(); // åŠ è½½æ¼”ç¤ºæ•°æ®
                this.startAutoRefresh();
            },
            
            // åŠ è½½æ¼”ç¤ºGitHubæ•°æ®ï¼ˆæ¨¡æ‹ŸçœŸå®æ•°æ®ï¼‰
            loadDemoData() {
                this.demoGitHubData = [
                    {
                        nickname: "å¼ ä¸‰",
                        score: 9,
                        time: 125,
                        created_at: new Date(Date.now() - 3600000).toISOString(),
                        issue_url: "https://github.com/le0632/test/issues/1",
                        issue_number: 1,
                        from: "github"
                    },
                    {
                        nickname: "æå››",
                        score: 8,
                        time: 180,
                        created_at: new Date(Date.now() - 7200000).toISOString(),
                        issue_url: "https://github.com/le0632/test/issues/2",
                        issue_number: 2,
                        from: "github"
                    },
                    {
                        nickname: "ç‹äº”",
                        score: 10,
                        time: 95,
                        created_at: new Date(Date.now() - 10800000).toISOString(),
                        issue_url: "https://github.com/le0632/test/issues/3",
                        issue_number: 3,
                        from: "github"
                    }
                ];
            },
            
            async loadRanking() {
                try {
                    this.showSyncStatus('æ­£åœ¨åŠ è½½æ’è¡Œæ¦œ...', 'sync-loading');
                    
                    let githubData = [];
                    
                    // æ–¹æ³•1: å°è¯•ç›´æ¥ä½¿ç”¨GitHub APIï¼ˆå¯èƒ½è¢«CORSé˜»æ­¢ï¼‰
                    try {
                        const response = await fetch('https://api.github.com/repos/le0632/test/issues?labels=quiz-score&state=all&per_page=100&sort=created&direction=desc');
                        if (response.ok) {
                            const data = await response.json();
                            githubData = this.parseIssuesToRanking(data);
                            console.log('GitHub APIè°ƒç”¨æˆåŠŸ', githubData.length);
                        }
                    } catch (error) {
                        console.log('GitHub APIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æ¼”ç¤ºæ•°æ®:', error.message);
                        // ä½¿ç”¨æ¼”ç¤ºæ•°æ®
                        githubData = this.demoGitHubData;
                    }
                    
                    // æ–¹æ³•2: å¦‚æœæ–¹æ³•1å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨JSONPæ–¹å¼ï¼ˆéœ€è¦åç«¯æ”¯æŒï¼‰
                    if (githubData.length === 0) {
                        try {
                            githubData = await this.tryJsonpMethod();
                        } catch (error) {
                            console.log('JSONPæ–¹æ³•å¤±è´¥:', error.message);
                        }
                    }
                    
                    // åˆå¹¶æœ¬åœ°æ•°æ®
                    const localRanking = this.getLocalRanking();
                    const combinedRanking = this.combineRankings(githubData, localRanking);
                    
                    this.currentRanking = combinedRanking;
                    
                    // æ›´æ–°æ•°æ®æºæ˜¾ç¤º
                    this.updateRankingSource(githubData.length, localRanking.length);
                    
                    this.showSyncStatus('æ’è¡Œæ¦œåŠ è½½æˆåŠŸï¼', 'sync-success');
                    setTimeout(() => this.hideSyncStatus(), 2000);
                    
                    return combinedRanking;
                    
                } catch (error) {
                    console.error('åŠ è½½æ’è¡Œæ¦œå¤±è´¥:', error);
                    this.showSyncStatus('ä½¿ç”¨æœ¬åœ°æ•°æ®', 'sync-error');
                    
                    const localRanking = this.getLocalRanking();
                    this.currentRanking = localRanking;
                    this.updateRankingSource(0, localRanking.length);
                    return localRanking;
                }
            },
            
            // å°è¯•JSONPæ–¹å¼è·å–æ•°æ®
            async tryJsonpMethod() {
                return new Promise((resolve, reject) => {
                    // ç”±äºCORSé™åˆ¶ï¼Œè¿™é‡Œä½¿ç”¨å›è°ƒå‡½æ•°
                    const callbackName = 'githubCallback_' + Date.now();
                    window[callbackName] = function(data) {
                        delete window[callbackName];
                        document.body.removeChild(script);
                        resolve(data);
                    };
                    
                    const script = document.createElement('script');
                    script.src = `https://api.github.com/repos/le0632/test/issues?labels=quiz-score&state=all&per_page=100&sort=created&direction=desc&callback=${callbackName}`;
                    script.onerror = reject;
                    document.body.appendChild(script);
                    
                    // 5ç§’è¶…æ—¶
                    setTimeout(() => {
                        if (window[callbackName]) {
                            delete window[callbackName];
                            document.body.removeChild(script);
                            reject(new Error('JSONPè¯·æ±‚è¶…æ—¶'));
                        }
                    }, 5000);
                });
            },
            
            updateRankingSource(githubCount, localCount) {
                const sourceElement = document.getElementById('ranking-source');
                if (!sourceElement) return;
                
                if (githubCount > 0 && localCount > 0) {
                    sourceElement.textContent = `æ•°æ®: GitHub(${githubCount}) + æœ¬åœ°(${localCount})`;
                    sourceElement.style.color = '#28a745';
                } else if (githubCount > 0) {
                    sourceElement.textContent = `æ•°æ®æ¥è‡ªGitHub Issues (${githubCount}æ¡)`;
                    sourceElement.style.color = '#28a745';
                } else if (localCount > 0) {
                    sourceElement.textContent = `æ•°æ®æ¥è‡ªæœ¬åœ°å­˜å‚¨ (${localCount}æ¡)`;
                    sourceElement.style.color = '#f39c12';
                } else {
                    sourceElement.textContent = 'æš‚æ— æ•°æ®';
                    sourceElement.style.color = '#6c757d';
                }
            },
            
            parseIssuesToRanking(issues) {
                const ranking = [];
                if (!Array.isArray(issues)) return ranking;
                
                issues.forEach(issue => {
                    try {
                        if (!issue.title || !issue.title.includes('æˆç»©')) return;
                        
                        let nickname = '', score = 0, total = 10, time = 0;
                        const match = issue.title.match(/æˆç»© - (.+?) - å¾—åˆ†:(\d+)\/(\d+) - ç”¨æ—¶:(\d+)ç§’/);
                        
                        if (match) {
                            [, nickname, score, total, time] = match;
                        } else {
                            nickname = issue.title.replace('æˆç»© - ', '').split(' - ')[0] || 'æœªçŸ¥ç”¨æˆ·';
                            
                            if (issue.body) {
                                const scoreMatch = issue.body.match(/å¾—åˆ†:\s*(\d+)\/(\d+)/);
                                const timeMatch = issue.body.match(/ç”¨æ—¶:\s*(\d+)/);
                                
                                if (scoreMatch) {
                                    score = parseInt(scoreMatch[1]) || 0;
                                    total = parseInt(scoreMatch[2]) || 10;
                                }
                                if (timeMatch) {
                                    time = parseInt(timeMatch[1]) || 0;
                                }
                            }
                        }
                        
                        ranking.push({
                            nickname: nickname.trim(),
                            score: parseInt(score),
                            total: parseInt(total),
                            time: parseInt(time),
                            created_at: issue.created_at,
                            issue_url: issue.html_url,
                            issue_number: issue.number,
                            from: 'github'
                        });
                    } catch (error) {
                        console.warn('è§£æIssueå¤±è´¥:', error);
                    }
                });
                
                return ranking;
            },
            
            combineRankings(githubRanking, localRanking) {
                const existingRecords = new Set();
                const combined = [];
                
                // å…ˆæ·»åŠ GitHubæ•°æ®
                githubRanking.forEach(item => {
                    const key = `${item.nickname}-${item.score}-${item.time}`;
                    combined.push(item);
                    existingRecords.add(key);
                });
                
                // æ·»åŠ æœ¬åœ°æ•°æ®ï¼ˆæ’é™¤é‡å¤ï¼‰
                localRanking.forEach(item => {
                    const key = `${item.nickname}-${item.score}-${item.time}`;
                    if (!existingRecords.has(key)) {
                        combined.push(item);
                    }
                });
                
                // æ’åºï¼šåˆ†æ•°ä¼˜å…ˆï¼Œç”¨æ—¶å…¶æ¬¡
                combined.sort((a, b) => {
                    if (a.score !== b.score) return b.score - a.score;
                    return a.time - b.time;
                });
                
                return combined.slice(0, 50);
            },
            
            async createScoreIssue(result) {
                this.saveToLocalStorage(result);
                
                const title = `æˆç»© - ${result.nickname} - å¾—åˆ†:${result.score}/${questions.length} - ç”¨æ—¶:${result.time}ç§’`;
                const body = this.formatIssueBody(result);
                
                const issueUrl = this.generateIssueUrl(title, body);
                
                return {
                    success: true,
                    issue_url: issueUrl,
                    message: 'è¯·ç‚¹å‡»é“¾æ¥åˆ›å»ºGitHub Issueæ¥ä¿å­˜æˆç»©'
                };
            },
            
            generateIssueUrl(title, body) {
                const encodedTitle = encodeURIComponent(title);
                const encodedBody = encodeURIComponent(body);
                return `https://github.com/le0632/test/issues/new?title=${encodedTitle}&body=${encodedBody}&labels=quiz-score`;
            },
            
            formatIssueBody(result) {
                const percentage = ((result.score / questions.length) * 100).toFixed(1);
                const timeStatus = TimeManager.isValidSubmission() ? 'æœ‰æ•ˆæäº¤' : 'è¶…æ—¶æäº¤';
                
                return `# ç­”é¢˜æˆç»©

**æ˜µç§°:** ${result.nickname}
**å¾—åˆ†:** ${result.score}/${questions.length} (${percentage}%)
**ç”¨æ—¶:** ${result.time}ç§’ (${this.formatTime(result.time)})
**æ—¶é—´é™åˆ¶:** 10åˆ†é’Ÿ
**æäº¤çŠ¶æ€:** ${timeStatus}
**æäº¤æ—¶é—´:** ${new Date().toLocaleString('zh-CN')}
**å¼€å§‹æ—¶é—´:** ${TimeManager.quizStartTime ? TimeManager.quizStartTime.toLocaleString('zh-CN') : 'N/A'}

## ç­”é¢˜è¯¦æƒ…
${this.generateAnswerDetails(result)}

---
*æ­¤Issueç”±ç­”é¢˜ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ*`.trim();
            },
            
            generateAnswerDetails(result) {
                let details = '';
                state.userAnswers.forEach((answer, index) => {
                    const question = questions[index];
                    const isCorrect = question.type === "choice" ? 
                        answer === question.answer : 
                        evaluateFillAnswer(answer, question.correctAnswers, question.requiredMatches);
                    
                    details += `\n### ç¬¬${index + 1}é¢˜: ${isCorrect ? 'âœ…' : 'âŒ'}\n`;
                    details += `**é—®é¢˜:** ${question.question}\n`;
                    
                    if (question.type === "choice") {
                        const userAnswer = question.options[answer];
                        const correctAnswer = question.options[question.answer];
                        details += `**æ‚¨çš„ç­”æ¡ˆ:** ${userAnswer || 'æœªå›ç­”'}\n`;
                        details += `**æ­£ç¡®ç­”æ¡ˆ:** ${correctAnswer}\n`;
                    } else {
                        details += `**æ‚¨çš„ç­”æ¡ˆ:** ${answer || 'æœªå›ç­”'}\n`;
                        details += `**å‚è€ƒç­”æ¡ˆ:** ${question.correctAnswers.slice(0, 3).join(', ')}...\n`;
                    }
                });
                return details;
            },
            
            saveToLocalStorage(result) {
                let ranking = JSON.parse(localStorage.getItem('ranking')) || [];
                ranking.push({
                    ...result,
                    from: 'local',
                    id: Date.now(),
                    created_at: new Date().toISOString(),
                    valid_submission: TimeManager.isValidSubmission(),
                    time_used: result.time
                });
                
                ranking = this.deduplicateAndSort(ranking);
                if (ranking.length > 100) ranking = ranking.slice(0, 100);
                localStorage.setItem('ranking', JSON.stringify(ranking));
            },
            
            getLocalRanking() {
                return JSON.parse(localStorage.getItem('ranking')) || [];
            },
            
            deduplicateAndSort(ranking) {
                const uniqueMap = new Map();
                ranking.forEach(item => {
                    const key = `${item.nickname}-${item.score}-${item.time}`;
                    if (!uniqueMap.has(key) || (item.id && item.id > uniqueMap.get(key).id)) {
                        uniqueMap.set(key, item);
                    }
                });
                
                const uniqueRanking = Array.from(uniqueMap.values());
                uniqueRanking.sort((a, b) => {
                    if (a.score !== b.score) return b.score - a.score;
                    return a.time - b.time;
                });
                
                return uniqueRanking;
            },
            
            startAutoRefresh() {
                if (this.autoRefreshInterval) clearInterval(this.autoRefreshInterval);
                
                this.autoRefreshInterval = setInterval(async () => {
                    if (this.autoRefreshEnabled) {
                        await this.refreshRankingIfVisible();
                    }
                }, 10000);
            },
            
            stopAutoRefresh() {
                if (this.autoRefreshInterval) {
                    clearInterval(this.autoRefreshInterval);
                    this.autoRefreshInterval = null;
                }
            },
            
            async refreshRankingIfVisible() {
                if (!document.getElementById('ranking-screen').classList.contains('hidden')) {
                    await refreshRanking();
                }
            },
            
            toggleAutoRefresh() {
                this.autoRefreshEnabled = !this.autoRefreshEnabled;
                const button = document.getElementById('auto-refresh-toggle');
                
                if (this.autoRefreshEnabled) {
                    button.textContent = 'è‡ªåŠ¨åˆ·æ–°: å¼€';
                    button.className = 'btn-success';
                    this.startAutoRefresh();
                } else {
                    button.textContent = 'è‡ªåŠ¨åˆ·æ–°: å…³';
                    button.className = 'btn-secondary';
                    this.stopAutoRefresh();
                }
            },
            
            getCurrentRanking() {
                return this.currentRanking;
            },
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            },
            
            showSyncStatus(message, type) {
                const statusEl = document.getElementById('sync-status');
                if (!statusEl) return;
                
                statusEl.innerHTML = type === 'sync-loading' ? 
                    `<div class="loading"></div>${message}` : message;
                statusEl.className = `sync-status ${type}`;
                statusEl.style.display = 'block';
            },
            
            showUploadStatus(message, type) {
                const statusEl = document.getElementById('upload-status');
                if (!statusEl) return;
                
                statusEl.innerHTML = type === 'sync-loading' ? 
                    `<div class="loading"></div>${message}` : message;
                statusEl.className = `sync-status ${type}`;
                statusEl.style.display = 'block';
            },
            
            hideSyncStatus() {
                const statusEl = document.getElementById('sync-status');
                if (statusEl) statusEl.style.display = 'none';
            }
        };

        // ==== åº”ç”¨çŠ¶æ€ ====
        let state = {
            currentUser: "",
            currentQuestionIndex: 0,
            userAnswers: [],
            startTime: null,
            timerInterval: null,
            elapsedTime: 0
        };

        // ==== æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ====
        function initApp() {
            GitHubService.init();
            
            // ç»‘å®šäº‹ä»¶
            document.getElementById('start-btn').addEventListener('click', startQuiz);
            document.getElementById('view-ranking-btn').addEventListener('click', showRanking);
            document.getElementById('view-ranking-btn-2').addEventListener('click', showRanking);
            document.getElementById('prev-btn').addEventListener('click', prevQuestion);
            document.getElementById('next-btn').addEventListener('click', nextQuestion);
            document.getElementById('restart-btn').addEventListener('click', restartQuiz);
            document.getElementById('back-to-start-btn').addEventListener('click', backToStart);
            document.getElementById('refresh-ranking-btn').addEventListener('click', refreshRanking);
            document.getElementById('auto-refresh-toggle').addEventListener('click', () => {
                GitHubService.toggleAutoRefresh();
            });
            document.getElementById('create-issue-btn').addEventListener('click', createGitHubIssue);
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å·²ä¿å­˜çš„ç”¨æˆ·æ•°æ®
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser) document.getElementById('nickname').value = savedUser;
            
            // è¾“å…¥æ¡†å›è½¦äº‹ä»¶
            document.getElementById('nickname').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') startQuiz();
            });
        }

        function startQuiz() {
            const nickname = document.getElementById('nickname').value.trim();
            if (!nickname) {
                alert('è¯·è¾“å…¥æ˜µç§°ï¼');
                return;
            }
            
            if (nickname.length < 2 || nickname.length > 10) {
                alert('æ˜µç§°é•¿åº¦åº”åœ¨2-10ä¸ªå­—ç¬¦ä¹‹é—´ï¼');
                return;
            }
            
            state.currentUser = nickname;
            state.currentQuestionIndex = 0;
            state.userAnswers = new Array(questions.length).fill(null);
            state.elapsedTime = 0;
            
            localStorage.setItem('currentUser', nickname);
            TimeManager.startQuiz();
            startTimer();
            
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('quiz-screen').classList.remove('hidden');
            document.getElementById('current-user').textContent = nickname;
            
            loadQuestion();
        }

        function loadQuestion() {
            const question = questions[state.currentQuestionIndex];
            const questionContainer = document.getElementById('question-container');
            
            const progress = ((state.currentQuestionIndex + 1) / questions.length) * 100;
            document.getElementById('progress-bar').style.width = `${progress}%`;
            document.getElementById('progress-text').textContent = `${state.currentQuestionIndex + 1}/${questions.length}`;
            
            let html = '';
            
            if (question.type === "choice") {
                html = `<div class="question"><h2>ç¬¬${state.currentQuestionIndex + 1}é¢˜ï¼ˆé€‰æ‹©é¢˜ï¼‰</h2><p>${question.question}</p><div class="options">`;
                
                question.options.forEach((option, index) => {
                    const isSelected = state.userAnswers[state.currentQuestionIndex] === index;
                    html += `<div class="option ${isSelected ? 'selected' : ''}" data-index="${index}">${String.fromCharCode(65 + index)}. ${option}</div>`;
                });
                
                html += '</div></div>';
            } else if (question.type === "fill") {
                const userAnswer = state.userAnswers[state.currentQuestionIndex] || '';
                html = `<div class="question"><h2>ç¬¬${state.currentQuestionIndex + 1}é¢˜ï¼ˆå¡«ç©ºé¢˜ï¼‰</h2><p>${question.question}</p><div class="form-group">
                    <label for="fill-answer">æ‚¨çš„ç­”æ¡ˆï¼š</label><input type="text" id="fill-answer" placeholder="è¯·è¾“å…¥ç­”æ¡ˆï¼Œå¤šä¸ªç­”æ¡ˆç”¨è‹±æ–‡é€—å·åˆ†éš”" value="${userAnswer}" style="width:100%;padding:12px">
                    <p style="margin-top:8px;font-size:14px;color:#666">æç¤ºï¼šè¯·è¾“å…¥${question.requiredMatches}ä¸ªæ­£ç¡®ç­”æ¡ˆå³å¯å¾—æ»¡åˆ†</p></div></div>`;
            }
            
            questionContainer.innerHTML = html;
            
            if (question.type === "choice") {
                document.querySelectorAll('.option').forEach(option => {
                    option.addEventListener('click', function() {
                        document.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        state.userAnswers[state.currentQuestionIndex] = parseInt(this.getAttribute('data-index'));
                    });
                });
            } else if (question.type === "fill") {
                const fillInput = document.getElementById('fill-answer');
                fillInput.addEventListener('input', function() {
                    state.userAnswers[state.currentQuestionIndex] = this.value.trim();
                });
                fillInput.focus();
            }
            
            document.getElementById('prev-btn').disabled = state.currentQuestionIndex === 0;
            document.getElementById('next-btn').textContent = state.currentQuestionIndex === questions.length - 1 ? 'æäº¤ç­”æ¡ˆ' : 'ä¸‹ä¸€é¢˜';
        }

        function prevQuestion() {
            if (state.currentQuestionIndex > 0) {
                state.currentQuestionIndex--;
                loadQuestion();
            }
        }

        function nextQuestion() {
            if (TimeManager.isTimeUp()) {
                alert('ç­”é¢˜æ—¶é—´å·²ç»“æŸï¼');
                submitQuiz();
                return;
            }
            
            const currentQuestion = questions[state.currentQuestionIndex];
            
            if (currentQuestion.type === "choice") {
                if (state.userAnswers[state.currentQuestionIndex] === null) {
                    alert('è¯·å…ˆé€‰æ‹©ç­”æ¡ˆï¼');
                    return;
                }
            } else if (currentQuestion.type === "fill") {
                if (!state.userAnswers[state.currentQuestionIndex] || state.userAnswers[state.currentQuestionIndex].trim() === '') {
                    alert('è¯·è¾“å…¥ç­”æ¡ˆï¼');
                    return;
                }
            }
            
            if (state.currentQuestionIndex < questions.length - 1) {
                state.currentQuestionIndex++;
                loadQuestion();
            } else {
                submitQuiz();
            }
        }

        async function submitQuiz() {
            TimeManager.stopCountdown();
            clearInterval(state.timerInterval);
            
            let score = 0;
            state.userAnswers.forEach((answer, index) => {
                const question = questions[index];
                if (question.type === "choice") {
                    if (answer === question.answer) score++;
                } else if (question.type === "fill") {
                    if (answer && evaluateFillAnswer(answer, question.correctAnswers, question.requiredMatches)) score++;
                }
            });
            
            const actualTimeUsed = TimeManager.getTimeUsed();
            state.elapsedTime = actualTimeUsed;
            
            document.getElementById('final-score').textContent = `${score}/${questions.length}`;
            document.getElementById('final-time').textContent = formatTime(actualTimeUsed);
            
            const isValid = TimeManager.isValidSubmission();
            const resultTitle = document.getElementById('result-title');
            
            if (!isValid) {
                resultTitle.textContent = 'ç­”é¢˜å®Œæˆï¼ˆè¶…æ—¶æäº¤ï¼‰';
                resultTitle.style.color = '#e74c3c';
                GitHubService.showUploadStatus('âš ï¸ è¶…æ—¶æäº¤ï¼Œæˆç»©å¯èƒ½æ— æ•ˆ', 'sync-warning');
            } else {
                resultTitle.textContent = 'ç­”é¢˜å®Œæˆï¼';
                resultTitle.style.color = '#2ecc71';
            }
            
            document.getElementById('quiz-screen').classList.add('hidden');
            document.getElementById('result-screen').classList.remove('hidden');
            
            saveResult(score, actualTimeUsed);
        }

        function saveResult(score, timeUsed) {
            const result = {
                nickname: state.currentUser,
                score: score,
                time: timeUsed,
                date: new Date().toISOString(),
                valid_submission: TimeManager.isValidSubmission()
            };
            GitHubService.saveToLocalStorage(result);
        }

        function evaluateFillAnswer(userAnswer, correctAnswers, requiredMatches) {
            if (!userAnswer) return false;
            
            const userAnswers = userAnswer.split(',')
                .map(ans => ans.trim().toLowerCase())
                .filter(ans => ans.length > 0);
            
            let matchCount = 0;
            const matchedCorrect = new Set();
            
            userAnswers.forEach(userAns => {
                for (const correctAns of correctAnswers) {
                    const normalizedCorrect = correctAns.trim().toLowerCase();
                    if (userAns === normalizedCorrect && !matchedCorrect.has(normalizedCorrect)) {
                        matchCount++;
                        matchedCorrect.add(normalizedCorrect);
                        break;
                    }
                }
            });
            
            return matchCount >= requiredMatches;
        }

        async function createGitHubIssue() {
            const score = parseInt(document.getElementById('final-score').textContent.split('/')[0]);
            const result = {
                nickname: state.currentUser,
                score: score,
                time: state.elapsedTime,
                date: new Date().toISOString()
            };
            
            try {
                GitHubService.showUploadStatus('æ­£åœ¨ç”ŸæˆGitHub Issueé“¾æ¥...', 'sync-loading');
                const issueResult = await GitHubService.createScoreIssue(result);
                
                if (issueResult.success) {
                    GitHubService.showUploadStatus('âœ… GitHub Issueé“¾æ¥å·²ç”Ÿæˆ', 'sync-success');
                    window.open(issueResult.issue_url, '_blank');
                }
            } catch (error) {
                console.error('åˆ›å»ºGitHub Issueå¤±è´¥:', error);
                GitHubService.showUploadStatus('âŒ åˆ›å»ºIssueå¤±è´¥', 'sync-error');
            }
        }

        async function showRanking() {
            try {
                const currentRanking = GitHubService.getCurrentRanking();
                if (currentRanking && currentRanking.length > 0) {
                    displayRanking(currentRanking);
                } else {
                    document.getElementById('ranking-body').innerHTML = 
                        `<tr><td colspan="5" style="text-align:center;padding:40px">
                        <div class="loading"></div><p style="margin-top:10px">æ­£åœ¨åŠ è½½æ’è¡Œæ¦œ...</p></td></tr>`;
                }
                
                if (!document.getElementById('ranking-screen').classList.contains('hidden')) return;
                
                document.getElementById('result-screen').classList.add('hidden');
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('quiz-screen').classList.add('hidden');
                document.getElementById('ranking-screen').classList.remove('hidden');
                
                await refreshRanking();
                
            } catch (error) {
                console.error('æ˜¾ç¤ºæ’è¡Œæ¦œå¤±è´¥:', error);
                alert('åŠ è½½æ’è¡Œæ¦œå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•');
                
                document.getElementById('ranking-body').innerHTML = 
                    `<tr><td colspan="5" style="text-align:center;padding:40px;color:#dc3545">
                    <p>åŠ è½½å¤±è´¥: ${error.message}</p>
                    <p style="font-size:14px;margin-top:10px">è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åç‚¹å‡»"åˆ·æ–°æ’è¡Œæ¦œ"æŒ‰é’®é‡è¯•</p></td></tr>`;
            }
        }

        async function refreshRanking() {
            try {
                const ranking = await GitHubService.loadRanking();
                displayRanking(ranking);
            } catch (error) {
                console.error('åˆ·æ–°æ’è¡Œæ¦œå¤±è´¥:', error);
                document.getElementById('ranking-body').innerHTML = 
                    `<tr><td colspan="5" style="text-align:center;padding:40px;color:#dc3545">
                    <p>åˆ·æ–°å¤±è´¥: ${error.message}</p>
                    <p style="font-size:14px;margin-top:10px">æ­£åœ¨ä½¿ç”¨æœ¬åœ°æ•°æ®ï¼Œè¯·ç¨åé‡è¯•</p></td></tr>`;
            }
        }

        function displayRanking(ranking) {
            const rankingBody = document.getElementById('ranking-body');
            let html = '';
            
            if (!ranking || ranking.length === 0) {
                html = `<tr><td colspan="5" style="text-align:center;padding:40px"><div style="color:#7f8c8d">
                    <p>æš‚æ— æ’è¡Œæ¦œæ•°æ®</p><p style="font-size:14px;margin-top:10px">å®Œæˆç­”é¢˜åï¼Œç‚¹å‡»"åˆ›å»ºGitHub Issue"æ¥æäº¤æˆç»©</p></div></td></tr>`;
            } else {
                ranking.forEach((item, index) => {
                    let rowClass = '';
                    if (index === 0) rowClass = 'top-1';
                    else if (index === 1) rowClass = 'top-2';
                    else if (index === 2) rowClass = 'top-3';
                    
                    const isCurrentUser = item.nickname === state.currentUser;
                    const userBadge = isCurrentUser ? '<span class="badge badge-primary">æˆ‘</span>' : '';
                    const topBadge = index < 3 ? `<span class="badge badge-success">TOP ${index + 1}</span>` : '';
                    const sourceBadge = item.from === 'local' ? 
                        '<span class="badge badge-secondary">æœ¬åœ°</span>' : 
                        '<span class="badge badge-primary">GitHub</span>';
                    const validBadge = item.valid_submission === false ? '<span class="badge badge-warning">è¶…æ—¶</span>' : '';
                    const issueLink = item.issue_url ? `<a href="${item.issue_url}" target="_blank" title="æŸ¥çœ‹Issueè¯¦æƒ…">ğŸ”—</a>` : '';
                    const issueNumber = item.issue_number ? `#${item.issue_number}` : '';
                    
                    html += `<tr class="${rowClass}"><td>${index + 1}</td>
                        <td>${item.nickname} ${userBadge} ${topBadge} ${sourceBadge} ${validBadge} ${issueNumber} ${issueLink}</td>
                        <td>${item.score}/${item.total || questions.length}</td>
                        <td>${GitHubService.formatTime(item.time)}</td>
                        <td>${formatDate(item.created_at)}</td></tr>`;
                });
            }
            
            rankingBody.innerHTML = html;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('zh-CN') + ' ' + date.toLocaleTimeString('zh-CN', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        }

        function restartQuiz() {
            TimeManager.reset();
            document.getElementById('result-screen').classList.add('hidden');
            document.getElementById('login-screen').classList.remove('hidden');
        }

        function backToStart() {
            document.getElementById('ranking-screen').classList.add('hidden');
            document.getElementById('login-screen').classList.remove('hidden');
        }

        function startTimer() {
            state.timerInterval = setInterval(() => {
                state.elapsedTime += 1;
                document.getElementById('timer').textContent = formatTime(state.elapsedTime);
            }, 1000);
        }

        // åˆå§‹åŒ–åº”ç”¨
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
